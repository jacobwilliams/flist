var tipuesearch = {"pages":[{"title":" flist ","text":"flist Modern Fortran Linked List Description Just some experiments with modern Fortran linked lists and unlimited polymorphic derived types. Compiling A Fortran Package Manager manifest file is included, so that the library and tests cases can be compiled with FPM. For example: fpm build --profile release\nfpm test --profile release To use flist within your fpm project, add the following to your fpm.toml file: [dependencies] flist = { git = \"https://github.com/jacobwilliams/flist.git\" } Documentation The API documentation for the current master branch can be found here .  This is generated by processing the source files with FORD . License The flist source code and related files and documentation are distributed under a permissive free software license (BSD-3). See also J. Williams, Linked Lists , Apr 5, 2016 [degenerateconic.com] Developer Info Jacob Williams","tags":"home","url":"index.html"},{"title":"node – flist ","text":"type, public :: node a node in the linked list. This is the container to\nthe unlimited polymorphic value variable. Inherited by type~~node~~InheritedByGraph type~node node type~node->type~node next, previous type~list list type~list->type~node head, tail Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial class(*), private, allocatable :: key the key (can be integer, string, or key_class ) class(*), private, pointer :: value => null() the data to hold logical, private :: destroy_on_delete = .true. if true, value pointer is deallocated\nwhen it is removed from the list,\nor the list is destroyed. If false,\nit is only nullified. type( node ), private, pointer :: next => null() the next one in the list type( node ), private, pointer :: previous => null() the previous one in the list Type-Bound Procedures procedure, public :: destroy => destroy_node_data deallocate value private impure elemental subroutine destroy_node_data (me) destroy the data in the node. Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: me procedure, public :: get_data => get_node_data get data from a node private  subroutine get_node_data (me, value) Get the data from a node Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: me class(*), intent(out), pointer :: value Source Code type , public :: node !! a node in the linked list. This is the container to !! the unlimited polymorphic `value` variable. private class ( * ), allocatable :: key !! the key (can be integer, string, or [[key_class]]) class ( * ), pointer :: value => null () !! the data to hold logical :: destroy_on_delete = . true . !! if true, value pointer is deallocated !! when it is removed from the list, !! or the list is destroyed. If false, !! it is only nullified. type ( node ), pointer :: next => null () !! the next one in the list type ( node ), pointer :: previous => null () !! the previous one in the list contains private procedure , public :: destroy => destroy_node_data !! deallocate value procedure , public :: get_data => get_node_data !! get data from a node end type node","tags":"","url":"type/node.html"},{"title":"list – flist ","text":"type, public :: list linked list of pointers to polymorphic types. Inherits type~~list~~InheritsGraph type~list list type~node node type~list->type~node head, tail type~node->type~node next, previous Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, private :: case_sensitive = .true. character key lookup is case sensitive integer, private :: count = 0 number of items in the list type( node ), private, pointer :: head => null() the first item in the list type( node ), private, pointer :: tail => null() the last item in the list Constructor public        interface list private  function initialize_list (case_sensitive) result(lst) list constructor. Arguments Type Intent Optional Attributes Name logical, intent(in) :: case_sensitive if true, then string key\nsearches are case sensitive. Return Value type( list ) Finalization Procedures final :: list_finalizer private impure elemental subroutine list_finalizer (me) just a wrapper for destroy_list . Arguments Type Intent Optional Attributes Name type( list ), intent(inout) :: me Type-Bound Procedures procedure, public :: add_pointer add a pointer item to the list private  subroutine add_pointer (me, key, value, destroy_on_delete) Add an item to the list, and associate its pointer to the input value. Read more… Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key class(*), intent(in), pointer :: value value is unlimited polymorphic, so it can\nbe any scalar type. If the type includes\npointers or other objects that must be\ncleaned up when it is destroyed, then it\nshould include a finalizer. logical, intent(in), optional :: destroy_on_delete If false, the finalizer will\nnot be called when the item is\nremoved from the list (the\npointer will only be\nnullified, so the caller is\nresponsible for cleaning it up\nto avoid memory leaks).\nThe default is True . procedure, public :: add_clone add a non-pointer item to the list private  subroutine add_clone (me, key, value) Add an item to the end of the list by cloning it.\nThat is, using a sourced allocation: allocate(newitem, source=value) .\nA clone is made of the original value, which is not affected.\nThe list contains only the clone, which will be deallocated (and\nfinalized if a finalizer is present) when removed from the list. Read more… Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key class(*), intent(in) :: value procedure, public :: get => get_data get a pointer to an item in the list private  subroutine get_data (me, key, value) Returns a pointer to the data stored in the list. Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: me class(*), intent(in) :: key class(*), intent(out), pointer :: value procedure, public :: destroy => destroy_list destroy the list and\ndeallocate/finalize all the data private impure elemental subroutine destroy_list (me) destroy the list (traverses from head to tail) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me procedure, public :: has_key if the key is present in the list private  function has_key (me, key) Returns true if the key is present in the list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key Return Value logical procedure, public :: traverse traverse the list are return each key & value private  subroutine traverse (me, iterator) traverse list from head to tail, and call the iterator function for each key. Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me procedure( key_iterator ) :: iterator the function to call for each node. procedure, public :: remove => remove_by_key remove item from the list, given the key private  subroutine remove_by_key (me, key) Remove an item from the list (given the key). Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key procedure, public :: remove_by_pointer remove node from list, given pointer to it private  subroutine remove_by_pointer (me, p) Remove an item from the list. Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me type( node ), pointer :: p the item to remove procedure, public :: get_node get a pointer to a node in the list private  subroutine get_node (me, key, p_node) Returns a pointer to a node in a list. Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: me class(*), intent(in) :: key type( node ), intent(out), pointer :: p_node procedure, public :: traverse_list traverse each node of the list private  subroutine traverse_list (me, iterator) traverse list from head to tail, and call the iterator function for each node. Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me procedure( iterator_func ) :: iterator the function to call for each node. procedure, private :: keys_equal for testing key string equality private pure function keys_equal (me, k1, k2) Returns true if the two keys are equal. Read more… Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: me class(*), intent(in) :: k1 class(*), intent(in) :: k2 Return Value logical Source Code type , public :: list !! linked list of pointers to polymorphic types. private logical :: case_sensitive = . true . !! character key lookup is case sensitive integer :: count = 0 !! number of items in the list type ( node ), pointer :: head => null () !! the first item in the list type ( node ), pointer :: tail => null () !! the last item in the list contains private procedure , public :: add_pointer !! add a pointer item to the list procedure , public :: add_clone !! add a non-pointer item to the list procedure , public :: get => get_data !! get a pointer to an item in the list procedure , public :: destroy => destroy_list !! destroy the list and !! deallocate/finalize all the data procedure , public :: has_key !! if the key is present in the list procedure , public :: traverse !! traverse the list are return each key & value procedure , public :: remove => remove_by_key !! remove item from the list, given the key ! procedures that operate on nodes: procedure , public :: remove_by_pointer !! remove node from list, given pointer to it procedure , public :: get_node !! get a pointer to a node in the list procedure , public :: traverse_list !! traverse each node of the list !private routines: procedure :: keys_equal !! for testing key string equality final :: list_finalizer end type list","tags":"","url":"type/list.html"},{"title":"key_class – flist ","text":"type, public, abstract :: key_class Can be used as a key for the list.\nit can be extended to use any data as a key.\nall that is necessary is to define the == operator function.\nFor convienence, integer or characters keys are also\nallowed to be used. Type-Bound Procedures procedure( key_equal_func ), public, deferred :: key_equal pure elemental function key_equal_func(item1, item2) Prototype interface for equality operator for key_class . Arguments Type Intent Optional Attributes Name class( key_class ), intent(in) :: item1 class( key_class ), intent(in) :: item2 Return Value logical generic, public :: operator(==) => key_equal pure elemental function key_equal_func(item1, item2) Prototype interface for equality operator for key_class . Arguments Type Intent Optional Attributes Name class( key_class ), intent(in) :: item1 class( key_class ), intent(in) :: item2 Return Value logical Source Code type , abstract , public :: key_class !! Can be used as a key for the list. !! it can be extended to use any data as a key. !! all that is necessary is to define the == operator function. !! For convienence, integer or characters keys are also !! allowed to be used. contains !private  ! remove for now to work around intel compile bug. see issue #6 procedure ( key_equal_func ), deferred :: key_equal generic , public :: operator ( == ) => key_equal end type key_class","tags":"","url":"type/key_class.html"},{"title":"iterator_func – flist","text":"interface private  subroutine iterator_func(me, done) Arguments Type Intent Optional Attributes Name type( node ), pointer :: me logical, intent(out) :: done set to true to stop traversing Description internal function for traversing all nodes in a list","tags":"","url":"interface/iterator_func.html"},{"title":"key_iterator – flist","text":"interface private  subroutine key_iterator(key, value, done) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: key the node key class(*), pointer :: value pointer to the node value logical, intent(out) :: done set to true to stop traversing Description for traversing all keys in a list","tags":"","url":"interface/key_iterator.html"},{"title":"key_equal_func – flist","text":"interface private pure elemental function key_equal_func(item1, item2) Arguments Type Intent Optional Attributes Name class( key_class ), intent(in) :: item1 class( key_class ), intent(in) :: item2 Return Value logical Description interface for equality operator for key_class .","tags":"","url":"interface/key_equal_func.html"},{"title":"has_key – flist","text":"private  function has_key(me, key) Returns true if the key is present in the list Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key Return Value logical Calls proc~~has_key~~CallsGraph proc~has_key list%has_key proc~traverse_list list%traverse_list proc~has_key->proc~traverse_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function has_key ( me , key ) implicit none class ( list ), intent ( inout ) :: me class ( * ), intent ( in ) :: key logical :: has_key has_key = . false . ! traverse the list: call me % traverse_list ( key_search ) contains subroutine key_search ( p , done ) !! search for the key implicit none type ( node ), pointer :: p logical , intent ( out ) :: done has_key = me % keys_equal ( p % key , key ) done = has_key end subroutine key_search end function has_key","tags":"","url":"proc/has_key.html"},{"title":"initialize_list – flist","text":"private  function initialize_list(case_sensitive) result(lst) list constructor. Arguments Type Intent Optional Attributes Name logical, intent(in) :: case_sensitive if true, then string key\nsearches are case sensitive. Return Value type( list ) Called by proc~~initialize_list~~CalledByGraph proc~initialize_list initialize_list interface~list list interface~list->proc~initialize_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function initialize_list ( case_sensitive ) result ( lst ) implicit none type ( list ) :: lst logical , intent ( in ) :: case_sensitive !! if true, then string key !! searches are case sensitive. lst % case_sensitive = case_sensitive end function initialize_list","tags":"","url":"proc/initialize_list.html"},{"title":"keys_equal – flist","text":"private pure function keys_equal(me, k1, k2) Returns true if the two keys are equal. Allowing a key to be an integer or a character string\n(can be case sensitive or not), or alternately, a user-defined key_class . Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: me class(*), intent(in) :: k1 class(*), intent(in) :: k2 Return Value logical Calls proc~~keys_equal~~CallsGraph proc~keys_equal list%keys_equal proc~uppercase uppercase proc~keys_equal->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~keys_equal~~CalledByGraph proc~keys_equal list%keys_equal proc~get_node list%get_node proc~get_node->proc~keys_equal proc~add_pointer list%add_pointer proc~add_pointer->proc~get_node proc~get_data list%get_data proc~get_data->proc~get_node proc~remove_by_key list%remove_by_key proc~remove_by_key->proc~get_node proc~add_clone list%add_clone proc~add_clone->proc~add_pointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function keys_equal ( me , k1 , k2 ) implicit none class ( list ), intent ( in ) :: me class ( * ), intent ( in ) :: k1 class ( * ), intent ( in ) :: k2 logical :: keys_equal keys_equal = . false . if ( same_type_as ( k1 , k2 )) then select type ( k1 ) class is ( key_class ) select type ( k2 ) class is ( key_class ) keys_equal = k1 == k2 end select type is ( integer ) select type ( k2 ) type is ( integer ) keys_equal = k1 == k2 end select type is ( character ( len =* )) select type ( k2 ) type is ( character ( len =* )) if ( me % case_sensitive ) then keys_equal = k1 == k2 else keys_equal = uppercase ( k1 ) == uppercase ( k2 ) end if end select end select end if end function keys_equal","tags":"","url":"proc/keys_equal.html"},{"title":"uppercase – flist","text":"private pure function uppercase(str) result(string) Convert a string to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) Called by proc~~uppercase~~CalledByGraph proc~uppercase uppercase proc~keys_equal list%keys_equal proc~keys_equal->proc~uppercase proc~get_node list%get_node proc~get_node->proc~keys_equal proc~add_pointer list%add_pointer proc~add_pointer->proc~get_node proc~get_data list%get_data proc~get_data->proc~get_node proc~remove_by_key list%remove_by_key proc~remove_by_key->proc~get_node proc~add_clone list%add_clone proc~add_clone->proc~add_pointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function uppercase ( str ) result ( string ) implicit none character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: string integer :: i , idx character ( len =* ), parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character ( len =* ), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' string = str do i = 1 , len_trim ( str ) idx = index ( lower , str ( i : i )) if ( idx > 0 ) string ( i : i ) = upper ( idx : idx ) end do end function uppercase","tags":"","url":"proc/uppercase.html"},{"title":"traverse_list – flist","text":"private  subroutine traverse_list(me, iterator) traverse list from head to tail, and call the iterator function for each node. Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me procedure( iterator_func ) :: iterator the function to call for each node. Called by proc~~traverse_list~~CalledByGraph proc~traverse_list list%traverse_list proc~has_key list%has_key proc~has_key->proc~traverse_list proc~traverse list%traverse proc~traverse->proc~traverse_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine traverse_list ( me , iterator ) implicit none class ( list ), intent ( inout ) :: me procedure ( iterator_func ) :: iterator !! the function to call for each node. type ( node ), pointer :: p logical :: done done = . false . p => me % head do if ( associated ( p )) then call iterator ( p , done ) if ( done ) exit p => p % next else exit ! done end if end do end subroutine traverse_list","tags":"","url":"proc/traverse_list.html"},{"title":"traverse – flist","text":"private  subroutine traverse(me, iterator) traverse list from head to tail, and call the iterator function for each key. Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me procedure( key_iterator ) :: iterator the function to call for each node. Calls proc~~traverse~~CallsGraph proc~traverse list%traverse proc~traverse_list list%traverse_list proc~traverse->proc~traverse_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine traverse ( me , iterator ) implicit none class ( list ), intent ( inout ) :: me procedure ( key_iterator ) :: iterator !! the function to call for each node. call me % traverse_list ( key_iterator_wrapper ) contains subroutine key_iterator_wrapper ( me , done ) !! for calling the user-specified key_iterator function. implicit none type ( node ), pointer :: me logical , intent ( out ) :: done !! set to true to stop traversing call iterator ( me % key , me % value , done ) end subroutine key_iterator_wrapper end subroutine traverse","tags":"","url":"proc/traverse.html"},{"title":"destroy_node_data – flist","text":"private impure elemental subroutine destroy_node_data(me) destroy the data in the node. Type Bound node Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: me Called by proc~~destroy_node_data~~CalledByGraph proc~destroy_node_data node%destroy_node_data proc~destroy_node destroy_node proc~destroy_node->proc~destroy_node_data proc~destroy_node->proc~destroy_node proc~remove_by_pointer list%remove_by_pointer proc~remove_by_pointer->proc~destroy_node_data proc~add_pointer list%add_pointer proc~add_pointer->proc~remove_by_pointer proc~destroy_list list%destroy_list proc~destroy_list->proc~destroy_node proc~remove_by_key list%remove_by_key proc~remove_by_key->proc~remove_by_pointer proc~add_clone list%add_clone proc~add_clone->proc~add_pointer proc~list_finalizer list_finalizer proc~list_finalizer->proc~destroy_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code impure elemental subroutine destroy_node_data ( me ) implicit none class ( node ), intent ( inout ) :: me if ( allocated ( me % key )) deallocate ( me % key ) if ( me % destroy_on_delete ) then ! deallocates the pointer (and call any finalizer) ! (otherwise, it is up to the caller to do this) if ( associated ( me % value )) deallocate ( me % value ) end if nullify ( me % value ) end subroutine destroy_node_data","tags":"","url":"proc/destroy_node_data.html"},{"title":"list_finalizer – flist","text":"private impure elemental subroutine list_finalizer(me) just a wrapper for destroy_list . Arguments Type Intent Optional Attributes Name type( list ), intent(inout) :: me Calls proc~~list_finalizer~~CallsGraph proc~list_finalizer list_finalizer proc~destroy_list list%destroy_list proc~list_finalizer->proc~destroy_list proc~destroy_node destroy_node proc~destroy_list->proc~destroy_node proc~destroy_node->proc~destroy_node proc~destroy_node_data node%destroy_node_data proc~destroy_node->proc~destroy_node_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code impure elemental subroutine list_finalizer ( me ) implicit none type ( list ), intent ( inout ) :: me call me % destroy () end subroutine list_finalizer","tags":"","url":"proc/list_finalizer.html"},{"title":"destroy_list – flist","text":"private impure elemental subroutine destroy_list(me) destroy the list (traverses from head to tail) Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me Calls proc~~destroy_list~~CallsGraph proc~destroy_list list%destroy_list proc~destroy_node destroy_node proc~destroy_list->proc~destroy_node proc~destroy_node->proc~destroy_node proc~destroy_node_data node%destroy_node_data proc~destroy_node->proc~destroy_node_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~destroy_list~~CalledByGraph proc~destroy_list list%destroy_list proc~list_finalizer list_finalizer proc~list_finalizer->proc~destroy_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code impure elemental subroutine destroy_list ( me ) implicit none class ( list ), intent ( inout ) :: me me % count = 0 if ( associated ( me % head )) call destroy_node ( me % head ) nullify ( me % head ) nullify ( me % tail ) end subroutine destroy_list","tags":"","url":"proc/destroy_list.html"},{"title":"destroy_node – flist","text":"private impure recursive subroutine destroy_node(me) destroy the node (and subsequent ones in the list). Arguments Type Intent Optional Attributes Name type( node ), pointer :: me Calls proc~~destroy_node~~CallsGraph proc~destroy_node destroy_node proc~destroy_node->proc~destroy_node proc~destroy_node_data node%destroy_node_data proc~destroy_node->proc~destroy_node_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~destroy_node~~CalledByGraph proc~destroy_node destroy_node proc~destroy_node->proc~destroy_node proc~destroy_list list%destroy_list proc~destroy_list->proc~destroy_node proc~list_finalizer list_finalizer proc~list_finalizer->proc~destroy_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code impure recursive subroutine destroy_node ( me ) implicit none type ( node ), pointer :: me if ( associated ( me )) then call me % destroy () call destroy_node ( me % next ) nullify ( me % previous ) deallocate ( me ) nullify ( me ) end if end subroutine destroy_node","tags":"","url":"proc/destroy_node.html"},{"title":"remove_by_key – flist","text":"private  subroutine remove_by_key(me, key) Remove an item from the list (given the key). Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key Calls proc~~remove_by_key~~CallsGraph proc~remove_by_key list%remove_by_key proc~get_node list%get_node proc~remove_by_key->proc~get_node proc~remove_by_pointer list%remove_by_pointer proc~remove_by_key->proc~remove_by_pointer proc~keys_equal list%keys_equal proc~get_node->proc~keys_equal proc~destroy_node_data node%destroy_node_data proc~remove_by_pointer->proc~destroy_node_data proc~uppercase uppercase proc~keys_equal->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine remove_by_key ( me , key ) implicit none class ( list ), intent ( inout ) :: me class ( * ), intent ( in ) :: key type ( node ), pointer :: p call me % get_node ( key , p ) call me % remove_by_pointer ( p ) end subroutine remove_by_key","tags":"","url":"proc/remove_by_key.html"},{"title":"remove_by_pointer – flist","text":"private  subroutine remove_by_pointer(me, p) Remove an item from the list. Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me type( node ), pointer :: p the item to remove Calls proc~~remove_by_pointer~~CallsGraph proc~remove_by_pointer list%remove_by_pointer proc~destroy_node_data node%destroy_node_data proc~remove_by_pointer->proc~destroy_node_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~remove_by_pointer~~CalledByGraph proc~remove_by_pointer list%remove_by_pointer proc~add_pointer list%add_pointer proc~add_pointer->proc~remove_by_pointer proc~remove_by_key list%remove_by_key proc~remove_by_key->proc~remove_by_pointer proc~add_clone list%add_clone proc~add_clone->proc~add_pointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine remove_by_pointer ( me , p ) implicit none class ( list ), intent ( inout ) :: me type ( node ), pointer :: p !! the item to remove logical :: has_next , has_previous if ( associated ( p )) then call p % destroy () ! destroy the data has_next = associated ( p % next ) has_previous = associated ( p % previous ) if ( has_next . and . has_previous ) then !neither first nor last in a list p % previous % next => p % next p % next % previous => p % previous elseif ( has_next . and . . not . has_previous ) then !first one in a list me % head => p % next me % head % previous => null () elseif ( has_previous . and . . not . has_next ) then !last one in a list me % tail => p % previous me % tail % next => null () elseif (. not . has_previous . and . . not . has_next ) then !only one in the list me % head => null () me % tail => null () end if deallocate ( p ) nullify ( p ) me % count = me % count - 1 end if end subroutine remove_by_pointer","tags":"","url":"proc/remove_by_pointer.html"},{"title":"get_node_data – flist","text":"private  subroutine get_node_data(me, value) Get the data from a node Type Bound node Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: me class(*), intent(out), pointer :: value Source Code subroutine get_node_data ( me , value ) implicit none class ( node ), intent ( in ) :: me class ( * ), pointer , intent ( out ) :: value if ( associated ( me % value )) then value => me % value else error stop 'error: value pointer is not associated' end if end subroutine get_node_data","tags":"","url":"proc/get_node_data.html"},{"title":"get_data – flist","text":"private  subroutine get_data(me, key, value) Returns a pointer to the data stored in the list. Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: me class(*), intent(in) :: key class(*), intent(out), pointer :: value Calls proc~~get_data~~CallsGraph proc~get_data list%get_data proc~get_node list%get_node proc~get_data->proc~get_node proc~keys_equal list%keys_equal proc~get_node->proc~keys_equal proc~uppercase uppercase proc~keys_equal->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_data ( me , key , value ) implicit none class ( list ), intent ( in ) :: me class ( * ), intent ( in ) :: key class ( * ), pointer , intent ( out ) :: value type ( node ), pointer :: p call me % get_node ( key , p ) if ( associated ( p )) then value => p % value else value => null () end if end subroutine get_data","tags":"","url":"proc/get_data.html"},{"title":"get_node – flist","text":"private  subroutine get_node(me, key, p_node) Returns a pointer to a node in a list. Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: me class(*), intent(in) :: key type( node ), intent(out), pointer :: p_node Calls proc~~get_node~~CallsGraph proc~get_node list%get_node proc~keys_equal list%keys_equal proc~get_node->proc~keys_equal proc~uppercase uppercase proc~keys_equal->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_node~~CalledByGraph proc~get_node list%get_node proc~add_pointer list%add_pointer proc~add_pointer->proc~get_node proc~get_data list%get_data proc~get_data->proc~get_node proc~remove_by_key list%remove_by_key proc~remove_by_key->proc~get_node proc~add_clone list%add_clone proc~add_clone->proc~add_pointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_node ( me , key , p_node ) implicit none class ( list ), intent ( in ) :: me class ( * ), intent ( in ) :: key type ( node ), pointer , intent ( out ) :: p_node type ( node ), pointer :: p nullify ( p_node ) p => me % head do if ( associated ( p )) then if ( me % keys_equal ( p % key , key )) then p_node => p return end if p => p % next else return !not found end if end do end subroutine get_node","tags":"","url":"proc/get_node.html"},{"title":"add_clone – flist","text":"private  subroutine add_clone(me, key, value) Add an item to the end of the list by cloning it.\nThat is, using a sourced allocation: allocate(newitem, source=value) .\nA clone is made of the original value, which is not affected.\nThe list contains only the clone, which will be deallocated (and\nfinalized if a finalizer is present) when removed from the list. This is different from the add_pointer routine,\nwhich takes a pointer input. This one would normally be used for basic variables and types that\ndo not contain pointers to other variables (and are not pointed to by\nother variables) Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key class(*), intent(in) :: value Calls proc~~add_clone~~CallsGraph proc~add_clone list%add_clone proc~add_pointer list%add_pointer proc~add_clone->proc~add_pointer proc~get_node list%get_node proc~add_pointer->proc~get_node proc~remove_by_pointer list%remove_by_pointer proc~add_pointer->proc~remove_by_pointer proc~keys_equal list%keys_equal proc~get_node->proc~keys_equal proc~destroy_node_data node%destroy_node_data proc~remove_by_pointer->proc~destroy_node_data proc~uppercase uppercase proc~keys_equal->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_clone ( me , key , value ) implicit none class ( list ), intent ( inout ) :: me class ( * ), intent ( in ) :: key class ( * ), intent ( in ) :: value class ( * ), pointer :: p_value allocate ( p_value , source = value ) !make a copy call me % add_pointer ( key , p_value , destroy_on_delete = . true .) nullify ( p_value ) end subroutine add_clone","tags":"","url":"proc/add_clone.html"},{"title":"add_pointer – flist","text":"private  subroutine add_pointer(me, key, value, destroy_on_delete) Add an item to the list, and associate its pointer to the input value. Note If an item with the same key is already in the list,\n      it is removed and the new one will replace it. Type Bound list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key class(*), intent(in), pointer :: value value is unlimited polymorphic, so it can\nbe any scalar type. If the type includes\npointers or other objects that must be\ncleaned up when it is destroyed, then it\nshould include a finalizer. logical, intent(in), optional :: destroy_on_delete If false, the finalizer will\nnot be called when the item is\nremoved from the list (the\npointer will only be\nnullified, so the caller is\nresponsible for cleaning it up\nto avoid memory leaks).\nThe default is True . Calls proc~~add_pointer~~CallsGraph proc~add_pointer list%add_pointer proc~get_node list%get_node proc~add_pointer->proc~get_node proc~remove_by_pointer list%remove_by_pointer proc~add_pointer->proc~remove_by_pointer proc~keys_equal list%keys_equal proc~get_node->proc~keys_equal proc~destroy_node_data node%destroy_node_data proc~remove_by_pointer->proc~destroy_node_data proc~uppercase uppercase proc~keys_equal->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_pointer~~CalledByGraph proc~add_pointer list%add_pointer proc~add_clone list%add_clone proc~add_clone->proc~add_pointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_pointer ( me , key , value , destroy_on_delete ) implicit none class ( list ), intent ( inout ) :: me class ( * ), intent ( in ) :: key class ( * ), intent ( in ), pointer :: value !! *value* is unlimited polymorphic, so it can !! be any scalar type. If the type includes !! pointers or other objects that must be !! cleaned up when it is destroyed, then it !! should include a finalizer. logical , intent ( in ), optional :: destroy_on_delete !! If false, the finalizer will !! not be called when the item is !! removed from the list (the !! pointer will only be !! nullified, so the caller is !! responsible for cleaning it up !! to avoid memory leaks). !! The default is *True*. type ( node ), pointer :: p !only allowing integer, string, or key_class keys: select type ( key ) type is ( integer ) !ok type is ( character ( len =* )) if ( len_trim ( key ) < 1 ) error stop 'Error: key must be nonblank.' class is ( key_class ) !ok class default error stop 'Error: key must be an integer, character string, or key_class.' end select ! if the node is already there, then remove it call me % get_node ( key , p ) if ( associated ( p )) call me % remove_by_pointer ( p ) if ( associated ( me % tail )) then allocate ( me % tail % next ) !insert new item at the end p => me % tail % next p % previous => me % tail else allocate ( me % head ) !first item in the list p => me % head end if me % tail => p me % count = me % count + 1 allocate ( p % key , source = key ) p % value => value if ( present ( destroy_on_delete )) then p % destroy_on_delete = destroy_on_delete end if end subroutine add_pointer","tags":"","url":"proc/add_pointer.html"},{"title":"list – flist","text":"public interface list Calls interface~~list~~CallsGraph interface~list list proc~initialize_list initialize_list interface~list->proc~initialize_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function initialize_list (case_sensitive) result(lst) list constructor. Arguments Type Intent Optional Attributes Name logical, intent(in) :: case_sensitive if true, then string key\nsearches are case sensitive. Return Value type( list )","tags":"","url":"interface/list.html"},{"title":"linked_list_module – flist","text":"A generic list. It uses an unlimited polymorphic class(*) pointer variable to allow it\nto contain any type of data. The key can be an integer, string, or\nany user-defined key_class . Uses key_module iso_fortran_env module~~linked_list_module~~UsesGraph module~linked_list_module linked_list_module iso_fortran_env iso_fortran_env module~linked_list_module->iso_fortran_env module~key_module key_module module~linked_list_module->module~key_module module~key_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface list private  function initialize_list (case_sensitive) result(lst) list constructor. Arguments Type Intent Optional Attributes Name logical, intent(in) :: case_sensitive if true, then string key\nsearches are case sensitive. Return Value type( list ) Abstract Interfaces abstract interface private  subroutine iterator_func(me, done) internal function for traversing all nodes in a list Arguments Type Intent Optional Attributes Name type( node ), pointer :: me logical, intent(out) :: done set to true to stop traversing abstract interface private  subroutine key_iterator(key, value, done) for traversing all keys in a list Arguments Type Intent Optional Attributes Name class(*), intent(in) :: key the node key class(*), pointer :: value pointer to the node value logical, intent(out) :: done set to true to stop traversing Derived Types type, public :: node a node in the linked list. This is the container to\nthe unlimited polymorphic value variable. Components Type Visibility Attributes Name Initial class(*), private, allocatable :: key the key (can be integer, string, or key_class ) class(*), private, pointer :: value => null() the data to hold logical, private :: destroy_on_delete = .true. if true, value pointer is deallocated\nwhen it is removed from the list,\nor the list is destroyed. If false,\nit is only nullified. type( node ), private, pointer :: next => null() the next one in the list type( node ), private, pointer :: previous => null() the previous one in the list Type-Bound Procedures procedure, public :: destroy => destroy_node_data ../../ deallocate value procedure, public :: get_data => get_node_data ../../ get data from a node type, public :: list linked list of pointers to polymorphic types. Components Type Visibility Attributes Name Initial logical, private :: case_sensitive = .true. character key lookup is case sensitive integer, private :: count = 0 number of items in the list type( node ), private, pointer :: head => null() the first item in the list type( node ), private, pointer :: tail => null() the last item in the list Constructor private\n\n                    \n                    function initialize_list (case_sensitive) list constructor. Finalizations Procedures final :: list_finalizer Type-Bound Procedures procedure, public :: add_pointer ../../ add a pointer item to the list procedure, public :: add_clone ../../ add a non-pointer item to the list procedure, public :: get => get_data ../../ get a pointer to an item in the list procedure, public :: destroy => destroy_list ../../ destroy the list and\ndeallocate/finalize all the data procedure, public :: has_key ../../ if the key is present in the list procedure, public :: traverse ../../ traverse the list are return each key & value procedure, public :: remove => remove_by_key ../../ remove item from the list, given the key procedure, public :: remove_by_pointer ../../ remove node from list, given pointer to it procedure, public :: get_node ../../ get a pointer to a node in the list procedure, public :: traverse_list ../../ traverse each node of the list procedure, private :: keys_equal ../../ for testing key string equality Functions private  function has_key (me, key) Returns true if the key is present in the list Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key Return Value logical private  function initialize_list (case_sensitive) result(lst) list constructor. Arguments Type Intent Optional Attributes Name logical, intent(in) :: case_sensitive if true, then string key\nsearches are case sensitive. Return Value type( list ) private pure function keys_equal (me, k1, k2) Returns true if the two keys are equal. Read more… Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: me class(*), intent(in) :: k1 class(*), intent(in) :: k2 Return Value logical private pure function uppercase (str) result(string) Convert a string to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) Subroutines private  subroutine traverse_list (me, iterator) traverse list from head to tail, and call the iterator function for each node. Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me procedure( iterator_func ) :: iterator the function to call for each node. private  subroutine traverse (me, iterator) traverse list from head to tail, and call the iterator function for each key. Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me procedure( key_iterator ) :: iterator the function to call for each node. private impure elemental subroutine destroy_node_data (me) destroy the data in the node. Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: me private impure elemental subroutine list_finalizer (me) just a wrapper for destroy_list . Arguments Type Intent Optional Attributes Name type( list ), intent(inout) :: me private impure elemental subroutine destroy_list (me) destroy the list (traverses from head to tail) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me private impure recursive subroutine destroy_node (me) destroy the node (and subsequent ones in the list). Arguments Type Intent Optional Attributes Name type( node ), pointer :: me private  subroutine remove_by_key (me, key) Remove an item from the list (given the key). Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key private  subroutine remove_by_pointer (me, p) Remove an item from the list. Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me type( node ), pointer :: p the item to remove private  subroutine get_node_data (me, value) Get the data from a node Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: me class(*), intent(out), pointer :: value private  subroutine get_data (me, key, value) Returns a pointer to the data stored in the list. Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: me class(*), intent(in) :: key class(*), intent(out), pointer :: value private  subroutine get_node (me, key, p_node) Returns a pointer to a node in a list. Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: me class(*), intent(in) :: key type( node ), intent(out), pointer :: p_node private  subroutine add_clone (me, key, value) Add an item to the end of the list by cloning it.\nThat is, using a sourced allocation: allocate(newitem, source=value) .\nA clone is made of the original value, which is not affected.\nThe list contains only the clone, which will be deallocated (and\nfinalized if a finalizer is present) when removed from the list. Read more… Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key class(*), intent(in) :: value private  subroutine add_pointer (me, key, value, destroy_on_delete) Add an item to the list, and associate its pointer to the input value. Read more… Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: me class(*), intent(in) :: key class(*), intent(in), pointer :: value value is unlimited polymorphic, so it can\nbe any scalar type. If the type includes\npointers or other objects that must be\ncleaned up when it is destroyed, then it\nshould include a finalizer. logical, intent(in), optional :: destroy_on_delete If false, the finalizer will\nnot be called when the item is\nremoved from the list (the\npointer will only be\nnullified, so the caller is\nresponsible for cleaning it up\nto avoid memory leaks).\nThe default is True .","tags":"","url":"module/linked_list_module.html"},{"title":"key_module – flist","text":"A key to a linked list Uses iso_fortran_env module~~key_module~~UsesGraph module~key_module key_module iso_fortran_env iso_fortran_env module~key_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~key_module~~UsedByGraph module~key_module key_module module~linked_list_module linked_list_module module~linked_list_module->module~key_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private pure elemental function key_equal_func(item1, item2) interface for equality operator for key_class . Arguments Type Intent Optional Attributes Name class( key_class ), intent(in) :: item1 class( key_class ), intent(in) :: item2 Return Value logical Derived Types type, public, abstract :: key_class Can be used as a key for the list.\nit can be extended to use any data as a key.\nall that is necessary is to define the == operator function.\nFor convienence, integer or characters keys are also\nallowed to be used. Type-Bound Procedures procedure( key_equal_func ), public, deferred :: key_equal generic, public :: operator(==) => key_equal","tags":"","url":"module/key_module.html"},{"title":"linked_list_module.f90 – flist","text":"This file depends on sourcefile~~linked_list_module.f90~~EfferentGraph sourcefile~linked_list_module.f90 linked_list_module.f90 sourcefile~key_module.f90 key_module.f90 sourcefile~linked_list_module.f90->sourcefile~key_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 11/14/2015 !  license: BSD ! ! A generic list. ! ! It uses an unlimited polymorphic `class(*)` pointer variable to allow it ! to contain any type of data. The `key` can be an integer, string, or ! any user-defined [[key_class]]. module linked_list_module use iso_fortran_env use key_module implicit none private type , public :: node !! a node in the linked list. This is the container to !! the unlimited polymorphic `value` variable. private class ( * ), allocatable :: key !! the key (can be integer, string, or [[key_class]]) class ( * ), pointer :: value => null () !! the data to hold logical :: destroy_on_delete = . true . !! if true, value pointer is deallocated !! when it is removed from the list, !! or the list is destroyed. If false, !! it is only nullified. type ( node ), pointer :: next => null () !! the next one in the list type ( node ), pointer :: previous => null () !! the previous one in the list contains private procedure , public :: destroy => destroy_node_data !! deallocate value procedure , public :: get_data => get_node_data !! get data from a node end type node type , public :: list !! linked list of pointers to polymorphic types. private logical :: case_sensitive = . true . !! character key lookup is case sensitive integer :: count = 0 !! number of items in the list type ( node ), pointer :: head => null () !! the first item in the list type ( node ), pointer :: tail => null () !! the last item in the list contains private procedure , public :: add_pointer !! add a pointer item to the list procedure , public :: add_clone !! add a non-pointer item to the list procedure , public :: get => get_data !! get a pointer to an item in the list procedure , public :: destroy => destroy_list !! destroy the list and !! deallocate/finalize all the data procedure , public :: has_key !! if the key is present in the list procedure , public :: traverse !! traverse the list are return each key & value procedure , public :: remove => remove_by_key !! remove item from the list, given the key ! procedures that operate on nodes: procedure , public :: remove_by_pointer !! remove node from list, given pointer to it procedure , public :: get_node !! get a pointer to a node in the list procedure , public :: traverse_list !! traverse each node of the list !private routines: procedure :: keys_equal !! for testing key string equality final :: list_finalizer end type list interface list procedure :: initialize_list !! constructor for a list end interface abstract interface subroutine iterator_func ( me , done ) !! internal function for traversing all nodes in a list import :: node implicit none type ( node ), pointer :: me logical , intent ( out ) :: done !! set to true to stop traversing end subroutine iterator_func subroutine key_iterator ( key , value , done ) !! for traversing all keys in a list implicit none class ( * ), intent ( in ) :: key !! the node key class ( * ), pointer :: value !! pointer to the node value logical , intent ( out ) :: done !! set to true to stop traversing end subroutine key_iterator end interface contains !***************************************************************************************** !***************************************************************************************** !> !  Returns true if the key is present in the list function has_key ( me , key ) implicit none class ( list ), intent ( inout ) :: me class ( * ), intent ( in ) :: key logical :: has_key has_key = . false . ! traverse the list: call me % traverse_list ( key_search ) contains subroutine key_search ( p , done ) !! search for the key implicit none type ( node ), pointer :: p logical , intent ( out ) :: done has_key = me % keys_equal ( p % key , key ) done = has_key end subroutine key_search end function has_key !***************************************************************************************** !***************************************************************************************** !> !  list constructor. function initialize_list ( case_sensitive ) result ( lst ) implicit none type ( list ) :: lst logical , intent ( in ) :: case_sensitive !! if true, then string key !! searches are case sensitive. lst % case_sensitive = case_sensitive end function initialize_list !***************************************************************************************** !***************************************************************************************** !> !  traverse list from head to tail, and call the iterator function for each node. subroutine traverse_list ( me , iterator ) implicit none class ( list ), intent ( inout ) :: me procedure ( iterator_func ) :: iterator !! the function to call for each node. type ( node ), pointer :: p logical :: done done = . false . p => me % head do if ( associated ( p )) then call iterator ( p , done ) if ( done ) exit p => p % next else exit ! done end if end do end subroutine traverse_list !***************************************************************************************** !***************************************************************************************** !> !  traverse list from head to tail, and call the iterator function for each key. subroutine traverse ( me , iterator ) implicit none class ( list ), intent ( inout ) :: me procedure ( key_iterator ) :: iterator !! the function to call for each node. call me % traverse_list ( key_iterator_wrapper ) contains subroutine key_iterator_wrapper ( me , done ) !! for calling the user-specified key_iterator function. implicit none type ( node ), pointer :: me logical , intent ( out ) :: done !! set to true to stop traversing call iterator ( me % key , me % value , done ) end subroutine key_iterator_wrapper end subroutine traverse !***************************************************************************************** !***************************************************************************************** !> !  destroy the data in the node. impure elemental subroutine destroy_node_data ( me ) implicit none class ( node ), intent ( inout ) :: me if ( allocated ( me % key )) deallocate ( me % key ) if ( me % destroy_on_delete ) then ! deallocates the pointer (and call any finalizer) ! (otherwise, it is up to the caller to do this) if ( associated ( me % value )) deallocate ( me % value ) end if nullify ( me % value ) end subroutine destroy_node_data !***************************************************************************************** !***************************************************************************************** !> !  just a wrapper for [[destroy_list]]. impure elemental subroutine list_finalizer ( me ) implicit none type ( list ), intent ( inout ) :: me call me % destroy () end subroutine list_finalizer !***************************************************************************************** !***************************************************************************************** !> !  destroy the list (traverses from head to tail) impure elemental subroutine destroy_list ( me ) implicit none class ( list ), intent ( inout ) :: me me % count = 0 if ( associated ( me % head )) call destroy_node ( me % head ) nullify ( me % head ) nullify ( me % tail ) end subroutine destroy_list !***************************************************************************************** !***************************************************************************************** !> !  destroy the node (and subsequent ones in the list). impure recursive subroutine destroy_node ( me ) implicit none type ( node ), pointer :: me if ( associated ( me )) then call me % destroy () call destroy_node ( me % next ) nullify ( me % previous ) deallocate ( me ) nullify ( me ) end if end subroutine destroy_node !***************************************************************************************** !***************************************************************************************** !> !  Remove an item from the list (given the key). subroutine remove_by_key ( me , key ) implicit none class ( list ), intent ( inout ) :: me class ( * ), intent ( in ) :: key type ( node ), pointer :: p call me % get_node ( key , p ) call me % remove_by_pointer ( p ) end subroutine remove_by_key !***************************************************************************************** !***************************************************************************************** !> !  Remove an item from the list. subroutine remove_by_pointer ( me , p ) implicit none class ( list ), intent ( inout ) :: me type ( node ), pointer :: p !! the item to remove logical :: has_next , has_previous if ( associated ( p )) then call p % destroy () ! destroy the data has_next = associated ( p % next ) has_previous = associated ( p % previous ) if ( has_next . and . has_previous ) then !neither first nor last in a list p % previous % next => p % next p % next % previous => p % previous elseif ( has_next . and . . not . has_previous ) then !first one in a list me % head => p % next me % head % previous => null () elseif ( has_previous . and . . not . has_next ) then !last one in a list me % tail => p % previous me % tail % next => null () elseif (. not . has_previous . and . . not . has_next ) then !only one in the list me % head => null () me % tail => null () end if deallocate ( p ) nullify ( p ) me % count = me % count - 1 end if end subroutine remove_by_pointer !***************************************************************************************** !***************************************************************************************** !> !  Get the data from a node subroutine get_node_data ( me , value ) implicit none class ( node ), intent ( in ) :: me class ( * ), pointer , intent ( out ) :: value if ( associated ( me % value )) then value => me % value else error stop 'error: value pointer is not associated' end if end subroutine get_node_data !***************************************************************************************** !***************************************************************************************** !> !  Returns a pointer to the data stored in the list. subroutine get_data ( me , key , value ) implicit none class ( list ), intent ( in ) :: me class ( * ), intent ( in ) :: key class ( * ), pointer , intent ( out ) :: value type ( node ), pointer :: p call me % get_node ( key , p ) if ( associated ( p )) then value => p % value else value => null () end if end subroutine get_data !***************************************************************************************** !***************************************************************************************** !> !  Returns a pointer to a node in a list. subroutine get_node ( me , key , p_node ) implicit none class ( list ), intent ( in ) :: me class ( * ), intent ( in ) :: key type ( node ), pointer , intent ( out ) :: p_node type ( node ), pointer :: p nullify ( p_node ) p => me % head do if ( associated ( p )) then if ( me % keys_equal ( p % key , key )) then p_node => p return end if p => p % next else return !not found end if end do end subroutine get_node !***************************************************************************************** !***************************************************************************************** !> !  Returns true if the two keys are equal. ! !  Allowing a key to be an integer or a character string !  (can be case sensitive or not), or alternately, a user-defined !  [[key_class]]. pure function keys_equal ( me , k1 , k2 ) implicit none class ( list ), intent ( in ) :: me class ( * ), intent ( in ) :: k1 class ( * ), intent ( in ) :: k2 logical :: keys_equal keys_equal = . false . if ( same_type_as ( k1 , k2 )) then select type ( k1 ) class is ( key_class ) select type ( k2 ) class is ( key_class ) keys_equal = k1 == k2 end select type is ( integer ) select type ( k2 ) type is ( integer ) keys_equal = k1 == k2 end select type is ( character ( len =* )) select type ( k2 ) type is ( character ( len =* )) if ( me % case_sensitive ) then keys_equal = k1 == k2 else keys_equal = uppercase ( k1 ) == uppercase ( k2 ) end if end select end select end if end function keys_equal !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to uppercase. pure function uppercase ( str ) result ( string ) implicit none character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: string integer :: i , idx character ( len =* ), parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character ( len =* ), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' string = str do i = 1 , len_trim ( str ) idx = index ( lower , str ( i : i )) if ( idx > 0 ) string ( i : i ) = upper ( idx : idx ) end do end function uppercase !***************************************************************************************** !***************************************************************************************** !> !  Add an item to the end of the list by *cloning* it. !  That is, using a sourced allocation: `allocate(newitem, source=value)`. !  A clone is made of the original value, which is not affected. !  The list contains only the clone, which will be deallocated (and !  finalized if a finalizer is present) when removed from the list. ! !  This is different from the [[list:add_pointer]] routine, !  which takes a pointer input. ! !  This one would normally be used for basic variables and types that !  do not contain pointers to other variables (and are not pointed to by !  other variables) subroutine add_clone ( me , key , value ) implicit none class ( list ), intent ( inout ) :: me class ( * ), intent ( in ) :: key class ( * ), intent ( in ) :: value class ( * ), pointer :: p_value allocate ( p_value , source = value ) !make a copy call me % add_pointer ( key , p_value , destroy_on_delete = . true .) nullify ( p_value ) end subroutine add_clone !***************************************************************************************** !***************************************************************************************** !> !  Add an item to the list, and associate its pointer to the input value. ! !@note If an item with the same key is already in the list, !      it is removed and the new one will replace it. subroutine add_pointer ( me , key , value , destroy_on_delete ) implicit none class ( list ), intent ( inout ) :: me class ( * ), intent ( in ) :: key class ( * ), intent ( in ), pointer :: value !! *value* is unlimited polymorphic, so it can !! be any scalar type. If the type includes !! pointers or other objects that must be !! cleaned up when it is destroyed, then it !! should include a finalizer. logical , intent ( in ), optional :: destroy_on_delete !! If false, the finalizer will !! not be called when the item is !! removed from the list (the !! pointer will only be !! nullified, so the caller is !! responsible for cleaning it up !! to avoid memory leaks). !! The default is *True*. type ( node ), pointer :: p !only allowing integer, string, or key_class keys: select type ( key ) type is ( integer ) !ok type is ( character ( len =* )) if ( len_trim ( key ) < 1 ) error stop 'Error: key must be nonblank.' class is ( key_class ) !ok class default error stop 'Error: key must be an integer, character string, or key_class.' end select ! if the node is already there, then remove it call me % get_node ( key , p ) if ( associated ( p )) call me % remove_by_pointer ( p ) if ( associated ( me % tail )) then allocate ( me % tail % next ) !insert new item at the end p => me % tail % next p % previous => me % tail else allocate ( me % head ) !first item in the list p => me % head end if me % tail => p me % count = me % count + 1 allocate ( p % key , source = key ) p % value => value if ( present ( destroy_on_delete )) then p % destroy_on_delete = destroy_on_delete end if end subroutine add_pointer !***************************************************************************************** !***************************************************************************************** end module linked_list_module !*****************************************************************************************","tags":"","url":"sourcefile/linked_list_module.f90.html"},{"title":"key_module.f90 – flist","text":"Files dependent on this one sourcefile~~key_module.f90~~AfferentGraph sourcefile~key_module.f90 key_module.f90 sourcefile~linked_list_module.f90 linked_list_module.f90 sourcefile~linked_list_module.f90->sourcefile~key_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  A key to a linked list module key_module use iso_fortran_env implicit none private type , abstract , public :: key_class !! Can be used as a key for the list. !! it can be extended to use any data as a key. !! all that is necessary is to define the == operator function. !! For convienence, integer or characters keys are also !! allowed to be used. contains !private  ! remove for now to work around intel compile bug. see issue #6 procedure ( key_equal_func ), deferred :: key_equal generic , public :: operator ( == ) => key_equal end type key_class abstract interface pure elemental logical function key_equal_func ( item1 , item2 ) !! interface for equality operator for [[key_class]]. import :: key_class implicit none class ( key_class ), intent ( in ) :: item1 class ( key_class ), intent ( in ) :: item2 end function key_equal_func end interface !***************************************************************************************** end module key_module !*****************************************************************************************","tags":"","url":"sourcefile/key_module.f90.html"}]}